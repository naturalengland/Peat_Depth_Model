---
title: "Peat Depth Model: Evaluate"
params:
  params_fn: 
    input: file
    label: 'Select parameters to import (.rds)'
    value: "../data/parameters_spade.rds"
  model_fn: 
    input: file
    label: 'Select model to import (.rds)'
    value: "../outputs/model.geo__spade_run_20200806-1552.rds"
  inputs_fn: 
    input: file
    label: 'Select input data to import (.rds)'
    value: "../outputs/input.data.gs_spade_run_20200806-1612.rds"
output:
    html_notebook:
    html_document:
    df_print: paged

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo= TRUE)
source("rsquared_funs.R")
source("backtransform.R")
```

-------  

Run at `r Sys.time()` for **`r params$area_name`** (*`r params$area_abbr`*) with the following parameters: 

```{r, echo=FALSE}
#import parameters from previous runs
parameters <- readRDS(file = params$params_fn)

# if you need to change any imported parameters, do it here, e.g.: 
  #parameters$existing_parameter <- newvalue
  #parameters$new_parameter <- value

parameters$tf <- "cbrt"

# add new parameters from yaml header

parameters <- c(parameters, params)

# print list of all parameters
parameters
  
#store graphics params in case things go wrong
par.ori <- par() #save default plotting parameters


```
```{r}
#pre-set which back-transformation to use

btf <- function(x) {
  backtransform(x = x, tf = parameters$tf)
}
```


-------    

## Introduction

This script evaluates a model using ten-fold cross validation and produces evaluation metrics.  

*  the suffix `.tf` means "transformed" and `.btf` means "back-transformed"


```{r}
#load packages
library(tidyverse)#
library(raster)
library(rgdal)
library(sp)
library(sf)
library(elevatr)
library(geoR)
library(gstat)
library(stars)
```
## 1. Import previously prepared data

import model and data
```{r}
if(!exists("model.geo")){model.geo <- readRDS(parameters$model_fn)}
if(!exists("sp_depth")){sp_depth <- readRDS(parameters$inputs_fn)}
```


```{r}
#columns which identify the model run
run_tag <- data.frame(area_abbr = rep(parameters$area_abbr, nrow(sp_depth)), rundate = rep(parameters$rundate, nrow(sp_depth)))

# the data used to generate the model
dat_sp <- cbind(sp_depth, 
                parameters$area_abbr, parameters$rundate)
names(dat_sp) <- c(names(sp_depth), "area_abbr", "rundate")
dat_sp$id <- seq(1,nrow(sp_depth))
```


```{r}
set.seed(4321)
```

## 4. Ten-fold cross validation    

This analysis uses the `gstat` function `krige.cv()` to perform ten-fold cross validation


```{r}
sm.cv.sp <- krige.cv(formula = cbrt_depth ~ elev + slope, 
                       locations = dat_sp, 
                       model = model.geo, 
                       nfold=10)
names(sm.cv.sp) <- c("pred.tf", "var", "obs.tf", "resid.tf", "zscore", "fold")

#backtransform
sm.cv.sp$pred.btf <- btf(sm.cv.sp$pred.tf)
sm.cv.sp$resid.btf <- sm.cv.sp$pred.btf - dat_sp$depth

#add run data
sm.cv <- sm.cv.sp@data  %>% 
  mutate( 
    id = seq(1,nrow(sp_depth)),
    LPI = pred.tf - 1.96 * sqrt(var),
    UPI = pred.tf + 1.96 * sqrt(var),
    obsInInt = obs.tf < UPI & obs.tf > LPI) %>% 
  #select(pred.tf, var, obs.tf, LPI, UPI, obsInInt) %>%
  bind_cols(run_tag) %>% 
  mutate(modeltype = "sm")  

#bubble(sm.cv.sp, "resid.btf", main = "10-fold CV residuals")
```
```{r}
cat(sep = "", "Spatial model cross-validation metrics (not back-transformed, ", parameters$area_abbr, "_", parameters$rundate,
# mean error, ideally 0:
"):\nmean error = ", mean(sm.cv$resid.tf) %>% round(3), 
# MSPE, ideally small
", MSPE = ", mean(sm.cv$resid.tf^2) %>% round(3),
#Mean square normalized error, ideally close to 1
", mean square norm. error = ", mean(sm.cv$zscore^2) %>% round(3),
# correlation observed and predicted, ideally 1
", \ncor obs&pred = ", cor(sm.cv$obs.tf, sm.cv$pred.tf) %>% round(3),
# correlation predicted and residual, ideally 0
", cor pred&resid = ", cor(sm.cv$pred.tf, sm.cv$resid.tf) %>% round(3),
# RSquared
", R2 = ", rsq(observed = sm.cv$obs.tf, predicted = sm.cv$pred.tf) %>% round(3),
# Adjusted RSquared
", R2 adj = ", rsq.adj(observed = sm.cv$obs.tf, predicted = sm.cv$pred.tf, n.predictors = 3, df.int = 1) %>% round(3)
)
```

```{r}
cat(sep = "", "Spatial model cross-validation metrics (back-transformed, ", parameters$area_abbr, "_", parameters$rundate,
# mean error, ideally 0:
"):\nmean error = ", mean(sm.cv$resid.btf) %>% round(3), 
# MSPE, ideally small
", MSPE = ", mean(sm.cv$resid.btf^2) %>% round(3),
# correlation observed and predicted, ideally 1
", \ncor obs&pred = ", cor(sp_depth$depth, sm.cv$pred.btf) %>% round(3),
# correlation predicted and residual, ideally 0
", cor pred&resid = ", cor(sm.cv$pred.btf, sm.cv$resid.btf) %>% round(3),
# RSquared
", R2 = ", rsq(observed = sp_depth$depth, predicted = sm.cv$pred.btf) %>% round(3),
# Adjusted RSquared
", R2 adj = ", rsq.adj(observed = sp_depth$depth, predicted = sm.cv$pred.btf, n.predictors = 3, df.int = 1) %>% round(3)
)
```



```{r}
#linear model cv
lm.cv.sp <- krige.cv(formula = cbrt_depth ~ elev + slope, 
                       locations = dat_sp, 
                       model = NULL, 
                       nfold=10)
names(lm.cv.sp) <- c("pred.tf", "var", "obs.tf", "resid.tf", "zscore", "fold")

#backtransform
lm.cv.sp$pred.btf <- btf(lm.cv.sp$pred.tf)
lm.cv.sp$resid.btf <- lm.cv.sp$pred.btf - dat_sp$depth

#add run data
lm.cv <- lm.cv.sp@data  %>% 
  mutate( 
    id = seq(1,nrow(sp_depth)),
    LPI = pred.tf - 1.96 * sqrt(var),
    UPI = pred.tf + 1.96 * sqrt(var),
    obsInInt = obs.tf < UPI & obs.tf > LPI) %>% 
  #select(pred.tf, var, obs.tf, LPI, UPI, obsInInt) %>%
  bind_cols(run_tag) %>% 
  mutate(modeltype = "lm") 

bubble(lm.cv.sp, "resid.btf", main = "10-fold CV residuals")
```


```{r}
cat(sep = "", "Linear model cross-validation metrics (not back-transformed, ", parameters$area_abbr, "_", parameters$rundate,
# mean error, ideally 0:
"):\nmean error = ", mean(lm.cv$resid.tf) %>% round(3), 
# MSPE, ideally small
", MSPE = ", mean(lm.cv$resid.tf^2) %>% round(3),
#Mean square normalized error, ideally close to 1
", mean square norm. error = ", mean(lm.cv$zscore^2) %>% round(3),
# correlation observed and predicted, ideally 1
", \ncor obs&pred = ", cor(lm.cv$obs.tf, lm.cv$pred.tf) %>% round(3),
# correlation predicted and residual, ideally 0
", cor pred&resid = ", cor(lm.cv$pred.tf, lm.cv$resid.tf) %>% round(3),
# RSquared
", R2 = ", rsq(observed = lm.cv$obs.tf, predicted = lm.cv$pred.tf) %>% round(3),
# Adjusted RSquared
", R2 adj = ", rsq.adj(observed = lm.cv$obs.tf, predicted = lm.cv$pred.tf, n.predictors = 3, df.int = 1) %>% round(3)
)
```

```{r}
cat(sep = "", "Linear model cross-validation metrics (back-transformed, ", parameters$area_abbr, "_", parameters$rundate,
# mean error, ideally 0:
"):\nmean error = ", mean(lm.cv$resid.btf) %>% round(3), 
# MSPE, ideally small
", MSPE = ", mean(lm.cv$resid.btf^2) %>% round(3),
# correlation observed and predicted, ideally 1
", \ncor obs&pred = ", cor(sp_depth$depth, lm.cv$pred.btf) %>% round(3),
# correlation predicted and residual, ideally 0
", cor pred&resid = ", cor(lm.cv$pred.btf, lm.cv$resid.btf) %>% round(3),
# RSquared
", R2 = ", rsq(observed = sp_depth$depth, predicted = lm.cv$pred.btf) %>% round(3),
# Adjusted RSquared
", R2 adj = ", rsq.adj(observed = sp_depth$depth, predicted = lm.cv$pred.btf, n.predictors = 3, df.int = 1) %>% round(3)
)
```
```{r}
#null model lm
lm.null <- lm(depth ~ elev + slope, dat_sp)
summary(lm.null)

  #save predictions
nullmodel <- data.frame(pred.btf = lm.null$fitted.values, modeltype = as.factor("null"), 
                        id = seq(1,nrow(dat_sp)),
                        area_abbr = parameters$area_abbr, rundate = parameters$rundate)

cat(sep = "", "Linear null-model metrics (", parameters$area_abbr, "_", parameters$rundate,
# mean error, ideally 0:
"):\nR2 = ", rsq(observed = lm.null$model$depth, predicted = lm.null$fitted.values) %>% round(3),
      ", R2 adj = ", rsq.adj(observed = lm.null$model$depth, predicted = lm.null$fitted.values,
                             n.predictors = 2, df.int = 1) %>% round(3),
      ", RMSE = ", rmse(observed = lm.null$model$depth, predicted = lm.null$fitted.values) %>% round(3), " cm")  

model_equation(model = lm.null)
```


```{r}
# Parry 1
#  lpdepth=Exp(0.875+0.00758*"dtm_metres"-0.0903*"slope_england")-25+(0.5*Exp(0.875+0.00758*"dtm_metres"-0.0903*"slope_england"))

pred.parry <- exp(0.875 + 0.00758 * dat_sp$elev - 0.0903 * dat_sp$slope) - 25 + (0.5 * exp(0.875 + 0.00758 * dat_sp$elev - 0.0903 * dat_sp$slope))

pred.parry <- data.frame(pred.btf = pred.parry, resid.btf = pred.parry - dat_sp$depth, 
                         modeltype = as.factor("parry"), id = seq(1,nrow(dat_sp)), 
                         area_abbr = parameters$area_abbr, rundate = parameters$rundate) 

cat(sep = "", "Exponential model by Parry, metrics (", parameters$area_abbr, "_", parameters$rundate,
# mean error, ideally 0:
"):\nR2 = ", rsq(observed = dat_sp$depth, predicted = pred.parry$pred.btf) %>% round(3),
      ", R2 adj = ", rsq.adj(observed = dat_sp$depth, predicted = pred.parry$pred.btf,
                             n.predictors = 2, df.int = 1) %>% round(3),
      ", RMSE = ", rmse(observed = dat_sp$depth, predicted = pred.parry$pred.btf) %>% round(3), " cm")

```

```{r}
#merge cv datasets and backtransform
results.cv <- bind_rows(sm.cv, lm.cv, nullmodel, pred.parry) %>% 
  full_join(dat_sp@data, by = c("id", "area_abbr", "rundate")) %>% 
  mutate_if(is.character, as.factor) %>% 
  select(id, area_abbr, rundate, depth:cbrt_depth, everything())
# summary(results.cv)
# table(results.cv$modeltype)
```
## 5. Summarise the results  


```{r}
# summarise backtransformed model metrics
table.metrics <- results.cv %>% 
  group_by(area_abbr, rundate, modeltype) %>% 
  summarise(
    rmse = rmse(observed = depth, predicted = pred.btf) %>% round(3), 
    r2 = rsq(observed = depth, predicted = pred.btf) %>% round(3),
    r2adj = rsq.adj(observed = depth, predicted = pred.btf, n.predictors = 3, df.int = 1) %>% round(3),
    cc = cor(depth, pred.btf),
    coverage = mean(obsInInt), 
    bias = mean(pred.btf - depth), 
    interv = btf(mean(UPI - LPI))
    )
table.metrics
```


```{r}
# summarise data and covariate space
predictors <- raster::stack(parameters$elev_raster_fn, parameters$slope_raster_fn)
names(predictors) <- c("elevation", "slope")

prdr.summ <- data.frame(dataset = "predictors", n_points = ncell(predictors), depth_med = as.numeric(NA), 
            depth_min = as.numeric(NA), depth_max = as.numeric(NA),
            elev_min = minValue(predictors$elevation) %>% round(2), elev_max = maxValue(predictors$elevation) %>% round(2),
            slope_min = minValue(predictors$slope) %>% round(2), slope_max = maxValue(predictors$slope) %>% round(2))
obs.summ <- dat_sp@data %>% summarise(dataset = "observations extract", n_points = length(depth), depth_med = median(depth), 
                  depth_min = min(depth), depth_max = max(depth), elev_min = min(elev), elev_max = max(elev),
                  slope_min = min(slope), slope_max = max(slope))
```




### visualise predictions

```{r}
#results.ty <- results.cv
```



```{r}
#graph predicted v observed values
ggplot(results.cv, aes(x = depth, y = pred.btf)) +
  geom_point(aes(colour = modeltype, shape = modeltype), position = position_dodge(width = 2))+
  geom_abline(slope = 1) +
  coord_equal() +
  geom_text(data = table.metrics %>% arrange(cc), 
            aes(x = 0, y = seq(max(graphdata$pred.btf), by = 50, length.out = length(unique(modeltype))), 
                colour = modeltype,
                label = paste0(modeltype, ": RMSE =", round(rmse, 2),
                              "cm, cc = ", round(cc, 2))),
            size = 3, show.legend = F, hjust = "left") +
  labs(title = "Predicted v observed values", subtitle = paste(parameters$area_abbr, parameters$rundate)) + 
  theme_minimal(base_size = 10)

  
ggsave(filename = paste0("../outputs/predvobs__", 
                         parameters$area_abbr, "_",
                         rundate, ".png"))
```


------------------------------------------------------------------------------  
## 5.5 Summary outputs

### Table 1. Summary statistics for input and prediction data

```{r}
rbind(prdr.summ, obs.summ)
```



### Table 2. Performance metrics for spatial and linear models from 10-fold cross-validation simulations


```{r}
table.metrics
```
#>>>>>>>>>>>>>> got this far

### Table xx. combined metrics for each model run

```{r}
#compile metrics
metrics.combined <- data.frame(
  run = rundate,
  dat = dat %>% summarise(n_points = length(depth), depth_med = median(depth), 
                          depth_min = min(depth), depth_max = max(depth),
                          elev_min = min(elev), elev_max = max(elev),
                          slope_min = min(slope), slope_max = max(slope)), 
  cv = data.frame(bias.lm, rmse.lm, coverage.lm, interv.lm, bias.sm, rmse.sm, coverage.sm, interv.sm),
  prdr = data.frame(dataset = "predictors", n_points = ncell(predictors), depth_med = as.numeric(NA), 
            depth_min = as.numeric(NA), depth_max = as.numeric(NA),
            elev_min = minValue(predictors$elevation), elev_max = maxValue(predictors$elevation),
            slope_min = minValue(predictors$slope), slope_max = maxValue(predictors$slope)),
  mod = data.frame(model.geo[c(1, 2, 4, 5, 6)],
                   intercept = model.geo$beta[[1]],
                   covar1 = model.geo$beta[[2]],
                   covar2 = model.geo$beta[[3]], 
                   model.geo[c(11, 12, 15, 17, 18)])
)


#make tidy
metrics.combined <- metrics.combined %>% mutate_all(as.character) %>% gather(key = metric, value = value, -run); metrics.combined 
#add to csv record
ifelse(file.exists("../outputs/metrics_combined.csv"), 
       yes = write_csv(metrics.combined, "../outputs/metrics_combined.csv", col_names = F, append = T), 
       no = write_csv(metrics.combined, "../outputs/metrics_combined.csv", col_names = T, append = F))
```




------------------------------------------------------------------------------  

## 6. Do some plots

##Variograms

#### Plot the semi-variogram to test for the presence of spatial autocorrelation

```{r}
residuals <- residuals(mod.lm.test)
resid.sp <- as.geodata(obj=dat.fit, coords.col=c("x", "y"), data.col="sqrt_depth", covar.col = c("elev", "slope"))
resid.sp <- jitterDupCoords(resid.sp, max=0.01)
vari1 <- variog(resid.sp)
vari1.mc <- variog.mc.env(resid.sp, obj.variog=vari1)

plot(vari1, envelope.obj = vari1.mc, xlab="Distance (m)",
     ylab="Estimated semi-variogram", main = "Spatial autocorrelation of residuals")
```

#### Empirical variograms
Empirical variograms are calculated using the function variog. There are options for the classical or modulus estimator. Results can be returned as variogram clouds, binned or smoothed variograms.

```{r}
plot(variog(input.data.gd))
```



```{r}
max_dist <- 400
cloud1 <- variog(input.data.gd, option = "cloud")#, max.dist = max_dist)
cloud2 <- variog(input.data.gd, option = "cloud", estimator.type = "modulus")#, max.dist = max_dist)
bin1 <- variog(input.data.gd)#, uvec=seq(0, max_dist, l=11))
bin2  <- variog(input.data.gd, estimator.type= "modulus")#, uvec=seq(0, max_dist, l=11))

par(mfrow=c(2,2), pch = 1)
plot(cloud1, main = "cloud: classical estimator")
plot(cloud2, main = "cloud: modulus estimator")
plot(bin1, main = "binned: classical estimator")
plot(bin2, main = "binned: modulus estimator")
#par(par.ori)
```
	  


##Compare model outputs

```{r}
#read in metrics from csv
model_metrics <- read_csv("../outputs/metrics_combined.csv")
```


```{r}
model_metrics_w <- model_metrics %>% spread(key = metric, value = value)
model_metrics_w
```

```{r}
ggplot(model_metrics_w, aes(x = cv.rmse.sm, y = cv.rmse.lm)) +
  geom_point(aes(colour = run)) +
  coord_equal() +
  expand_limits(x = 0, y = 0)


ggplot(model_metrics_w, aes(x = dat.n_points, y = cv.rmse.sm)) +
  geom_point(aes(colour = run))

```


```{r}
# export parameters
saveRDS(parameters,  paste0("../data/parameters_", 
                                      parameters$area_abbr, ".rds"))
```
